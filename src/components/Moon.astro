---
import { PhaseName } from "@/utils/types.utils";

interface Props {
  phaseName: PhaseName;
  percentage: number;
  shadow?: boolean;
  animate?: boolean;
}

const { phaseName, percentage, shadow, animate } = Astro.props;

const isWaning = [PhaseName.Waning, PhaseName.LastQuarter, PhaseName.NewMoon].includes(phaseName);

const percentageToRender = [PhaseName.NewMoon, PhaseName.FullMoon].includes(phaseName)
  ? 50
  : Math.floor(Number(percentage) - 50) * 0.84 + 0.16;
---

<figure class="relative p-[10%] overflow-hidden w-full aspect-square stage">
  <div
    id="moon"
    class="m-auto flex justify-center items-center"
    style=`
      ${shadow ? 'box-shadow: 0px 0px .2em .1em #ffffff33;' : ''}
      ${animate ? 'animation: move-map 120s infinite linear;' : 'background-position-x: 60%'}
    `
  ></div>

  <!-- El terminador se rota dinámicamente con JS -->
  <div
    id="moon-shape"
    class:list={[
      "w-full h-full absolute top-0 left-0",
      { "rotate-[-0deg]": ![PhaseName.LastQuarter, PhaseName.FirstQuarter].includes(phaseName) },
    ]}
    style="transform: rotate(0deg);"
  >
    <svg width="100%" height="100%" viewBox="0 0 100 100">
      <filter id="dropshadow" height="105%">
        <feGaussianBlur in="SourceGraphic" stdDeviation="2.5"></feGaussianBlur>
      </filter>
      <path
        d={`M 50 1 A 49,49 0
            ${isWaning ? "0,1" : "1,0"}
            50,100 A
            ${percentageToRender},50
            0
            ${(isWaning && percentage < 50) || (!isWaning && percentage > 50) ? "0,1" : "1,0"}
            50,1`}
        stroke-width="0" stroke="none" fill="#000000F1" style="filter:url(#dropshadow)"></path>
    </svg>
  </div>
</figure>

<section class="info">
  <div class="row">
    <!-- Puedes poner aquí el nombre de fase si lo renderizas fuera -->
    <!-- <span class="phase">{String(phaseName)}</span> -->
    <span class="pct">{Math.round(percentage)}%</span>
  </div>

  <div class="sub" id="moonTimes">Rise — / Set —</div>
  <div class="tiny" id="moonLocHint">Using your location if permitted.</div>

  <div class="list">
    <div class="list-title" id="nextTitle">Next phases</div>
    <ul id="nextPhases" class="ul"></ul>
  </div>
</section>

<style>
  /* Canvas y textura */
  .stage { width: 100%; display: inline-block; perspective: 400%; perspective-origin: 50% 50%; }
  #moon { width: 100%; height: 100%; background-image: url("/moon.webp"); background-position-y: center; background-size: 250% auto; border-radius: 50%; transform: rotate(170deg); }
  @keyframes move-map { 0% { background-position-x: -67%; } 100% { background-position-x: 100%; } }

  /* Info y tipografías fluidas */
  .info { text-align: center; margin-top: 14px; color: #e5e7eb; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; padding: 0 12px; }
  .row { font-weight: 800; font-size: clamp(20px, 3.5vw, 32px); line-height: 1.15; word-break: break-word; }
  .pct { font-size: clamp(12px, 2.2vw, 16px); opacity: .85; }
  .sub { margin-top: 6px; font-size: 14px; color: #a5b4fc; }
  .tiny { margin-top: 4px; font-size: 12px; color: #94a3b8; }

  /* Lista responsive de próximas fases */
  .list { margin: 16px auto 0; max-width: 880px; background:#0b1220; border:1px solid #1f2937; border-radius:12px; padding:12px; }
  .list-title { color:#93c5fd; font-weight:800; font-size: clamp(12px, 1.8vw, 14px); margin-bottom:8px; text-transform:uppercase; letter-spacing:.4px; }
  .ul { list-style:none; padding:0; margin:0; display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:10px; }
  .ul li { display:flex; justify-content:space-between; align-items:center; gap:10px; font-size: clamp(12px, 1.8vw, 14px); background:#0f172a; border:1px solid #1f2937; border-radius:10px; padding:10px 12px; min-height:44px; }
  .ul .label { color:#c7d2fe; font-weight:700; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .ul .value { color:#e5e7eb; font-variant-numeric: tabular-nums; white-space:nowrap; }
</style>

<script>
  // @ts-nocheck  (por si astro check intenta tipar este bloque)
  import SunCalc from 'suncalc';

  // i18n simple (auto ES/EN según navegador)
  const lang = (typeof navigator !== 'undefined' && navigator.language || 'en')
    .toLowerCase().startsWith('es') ? 'es' : 'en';

  const I18N = {
    es: {
      usingLoc: 'Usando tu ubicación.',
      generic: 'Usando orientación genérica.',
      riseSet: (r, s) => `Salida ${r} / Puesta ${s}`,
      nextPhases: 'Próximas fases',
      phases: ['Luna Nueva','Cuarto Creciente','Luna Llena','Cuarto Menguante'],
    },
    en: {
      usingLoc: 'Using your location.',
      generic: 'Using a generic orientation.',
      riseSet: (r, s) => `Rise ${r} / Set ${s}`,
      nextPhases: 'Next phases',
      phases: ['New Moon','First Quarter','Full Moon','Last Quarter'],
    }
  };
  const T = I18N[lang];

  const shape   = document.getElementById('moon-shape');
  const timesEl = document.getElementById('moonTimes');
  const hintEl  = document.getElementById('moonLocHint');
  const listEl  = document.getElementById('nextPhases');
  const nextTitleEl = document.getElementById('nextTitle');

  if (nextTitleEl) nextTitleEl.textContent = T.nextPhases;

  function setRotationAndTimes(lat = 0, lon = 0) {
    const now = new Date();
    const ill = SunCalc.getMoonIllumination(now);
    const pos = SunCalc.getMoonPosition(now, lat, lon);
    const angleRad = -(pos.parallacticAngle + ill.angle);
    const angleDeg = angleRad * 180 / Math.PI;
    if (shape) shape.style.transform = `rotate(${angleDeg}deg)`;

    try {
      const mt = SunCalc.getMoonTimes(now, lat, lon);
      const riseTxt = mt.rise ? new Date(mt.rise).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '—';
      const setTxt  = mt.set  ? new Date(mt.set ).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : '—';
      if (timesEl) timesEl.textContent = T.riseSet(riseTxt, setTxt);
    } catch {
      if (timesEl) timesEl.textContent = T.riseSet('—','—');
    }
  }

  // Próximas fases (búsqueda numérica local, sin API)
  const TARGETS = [
    { key: 0, value: 0.0  }, // New
    { key: 1, value: 0.25 }, // First Quarter
    { key: 2, value: 0.5  }, // Full
    { key: 3, value: 0.75 }, // Last Quarter
  ];

  function wrapErr(x) {
    x = ((x % 1) + 1) % 1;
    return x > 0.5 ? x - 1 : x;
  }

  async function findNextPhaseDates() {
    const out = [];
    const start = new Date();

    for (const t of TARGETS) {
      let minErr = 1e9;
      let candidate = new Date(start);

      // barrido 60 días, 4 muestras por día
      for (let d = 0; d < 60; d++) {
        const test = new Date(start.getTime() + d * 86400000);
        for (let h = 0; h < 24; h += 6) {
          const dt = new Date(test.getFullYear(), test.getMonth(), test.getDate(), h);
          const phase = SunCalc.getMoonIllumination(dt).phase;
          const err = Math.min(Math.abs(phase - t.value), 1 - Math.abs(phase - t.value));
          if (err < minErr) { minErr = err; candidate = dt; }
        }
      }
      // afinado binario ±36h
      let lo = new Date(candidate.getTime() - 36 * 3600 * 1000);
      let hi = new Date(candidate.getTime() + 36 * 3600 * 1000);
      for (let i = 0; i < 22; i++) {
        const mid = new Date((lo.getTime() + hi.getTime()) / 2);
        const phaseMid = SunCalc.getMoonIllumination(mid).phase;
        const errMid = wrapErr(phaseMid - t.value);
        const errLo  = wrapErr(SunCalc.getMoonIllumination(lo).phase - t.value);
        if (Math.abs(errLo) < Math.abs(errMid)) hi = mid; else lo = mid;
      }
      const best = new Date((lo.getTime() + hi.getTime()) / 2);
      out.push({ label: t.key, date: best });
    }
    return out.sort((a,b) => a.date - b.date);
  }

  function renderNextPhases(list) {
    if (!listEl) return;
    listEl.innerHTML = '';
    list.slice(0, 4).forEach((item) => {
      const li = document.createElement('li');

      const label = document.createElement('span');
      label.className = 'label';
      label.textContent = T.phases[item.label];

      const val = document.createElement('span');
      val.className = 'value';
      val.textContent = item.date.toLocaleString([], { month:'short', day:'2-digit', hour:'2-digit', minute:'2-digit' });

      li.appendChild(label);
      li.appendChild(val);
      listEl.appendChild(li);
    });
  }

  function init(lat = 0, lon = 0, usedGeo = false) {
    setRotationAndTimes(lat, lon);
    if (hintEl) hintEl.textContent = usedGeo ? T.usingLoc : T.generic;
    setInterval(() => setRotationAndTimes(lat, lon), 10 * 60 * 1000);
    findNextPhaseDates().then(renderNextPhases);
  }

  if (typeof navigator !== 'undefined' && navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      (pos) => init(pos.coords.latitude, pos.coords.longitude, true),
      ()    => init(),
      { enableHighAccuracy: false, timeout: 6000, maximumAge: 300000 }
    );
  } else {
    init();
  }
</script>
